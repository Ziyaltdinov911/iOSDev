//
//  main.swift
//
//  Created by Камиль Байдиев on 05.12.2023.
//
 
import Foundation

//MARK: - Task 1. Простое текстовое приложение для управления и отображения событий в календаре

//1. Задание Необходимо разработать простое текстовое приложение для управления и отображения событий в календаре.
// Требования:
// Хранилище данных:
// Создайте словарь для хранения событий. Ключом в этом словаре должна быть строка, представляющая дату, а значением - массив строк, представляющий события этой даты.
// Функциональность:
// a. Добавление события:
// Напишите функцию, которая принимает дату и событие в качестве параметров.
// Если для этой даты еще не существует списка событий, создайте его.
// Добавьте событие к указанной дате.
// b. Отображение событий:
// Напишите функцию, которая принимает дату в качестве параметра.
// Функция должна выводить все события этой даты или сообщение о том, что событий на указанную дату нет.
// Интерфейс пользователя:
// Создайте функцию, которая предоставляет пользователю следующие опции:
// Добавить мероприятие
// Показать мероприятия на определенную дату
// Выйти из приложения
// В зависимости от выбора пользователя вызывайте соответствующие функции.
// Для получения ввода от пользователя используйте функцию readLine().
// Убедитесь, что приложение корректно обрабатывает неверный ввод пользователя.
// Запуск:
// После того как весь функционал будет реализован, инициируйте запуск приложения.
// Подсказки:
// Используйте условные операторы и циклы для реализации логики.
// Помните о безопасности работы с опциональными значениями в Swift.
// Ожидаемый результат: При запуске приложения пользователь должен видеть меню с опциями. После выбора опции он может добавить событие к определенной дате или просмотреть события на выбранную дату. Приложение должно корректно обрабатывать ввод и предоставлять информативные сообщения пользователю.
//

var eventStorage = [String: [String]]()

func addEvent() {
    var arrayEvents = [String]()

    func addEvent(date: String, event: String) {
        arrayEvents.append(event)
        eventStorage[date] = arrayEvents
    }

    print("Введите дату:")
    guard let userDate = readLine(), !userDate.isEmpty else {
        print("Вы ничего не ввели")
        return
    }

    print("Введите мероприятие:")
    guard let userEvent = readLine(), !userEvent.isEmpty else {
        print("Вы ничего не ввели")
        return
    }

    addEvent(date: userDate, event: userEvent)
}

func showEvent() {
    print("Введите дату:")
    guard let userDate = readLine(), !userDate.isEmpty else {
        print("Вы ничего не ввели")
        return
    }

    print("Ваши мероприятия в эту дату:")
    print(eventStorage[userDate] ?? "Событий на указанную дату нет")
}

func calendar() {
    print("""
        Выберите действие (введите число):
        1 - Добавить мероприятие
        2 - Показать мероприятия на определенную дату
        3 - Выйти из приложения
        """)
    let userAnswer = readLine()

    switch userAnswer {
    case "1":
        addEvent()
        print("")
        calendar()
    case "2":
        showEvent()
        print("")
        calendar()
    case "3":
        print("Работа приложения завершена")
    default:
        print("Ошибка ввода, попробуйте еще раз\n")
        calendar()
    }
}

calendar()

// MARK: - Task 2. Хранилище настроек

//2 Задание: Хранилище настроек
// Описание: Разработайте текстовое приложение, которое позволяет пользователю устанавливать и извлекать значения настроек по ключам.
// Требования:
// Хранилище данных:
// Создайте приватный словарь для хранения настроек. Ключом в этом словаре должна быть строка, представляющая ключ настройки, а значением - строка, представляющая значение настройки.
// Функциональность:
//a. Установка настройки:
//Реализуйте метод, который принимает ключ и значение настройки в качестве параметров. Метод должен устанавливать или обновлять значение настройки по указанному ключу в вашем приватном словаре.
//b. Извлечение настройки:
//Реализуйте метод, который принимает ключ в качестве параметра и возвращает значение настройки для указанного ключа. Если ключ не существует, метод должен возвращать nil.
//
//c. Вывод всех настроек:
//Реализуйте метод для вывода всех настроек в удобочитаемом формате. Этот метод может быть полезен для пользователя, чтобы быстро проверить все текущие настройки.
//
//d. Защита от ошибок:
//Обеспечьте безопасность работы с вашим хранилищем настроек. Рассмотрите возможность добавления проверок на ввод данных, предоставление информативных сообщений об ошибках.

var settingStorage = [String: String]()

func addSetting(key: String, value: String) {
    settingStorage[key] = value
    print("Настройка с ключом '\(key)' установлена на значение '\(value)'")
}

func extractSetting(key: String) -> String? {
    return settingStorage[key]
}

func displayAllSettings() {
    if settingStorage.isEmpty {
        print("Настройки отсутствуют")
    } else {
        print("Текущие настройки:")
        for (key, value) in settingStorage {
            print("Ключ: '\(key)', Значение: '\(value)'")
        }
    }
}

// Пример использования
addSetting(key: "Language", value: "English")
addSetting(key: "Theme", value: "Dark")

if let language = extractSetting(key: "Language") {
    print("Выбранный язык: \(language)")
} else {
    print("Язык не установлен")
}

displayAllSettings()

//MARK: - Task 3. Простой англо-русский переводчик

//3 Задание: Простой англо-русский переводчик
// Описание: Разработайте текстовое приложение, которое позволяет пользователю переводить слова с английского языка на русский, используя предопределенный словарь.
// Требования:
// Словарь перевода:
// Создайте словарь с парами "английское слово": "русское слово".
// Например: "hello" переводится как "привет", "world" как "мир" и так далее.
// Этот словарь будет служить вашей базой для перевода слов.
// Функциональность:
// a. Перевод слова:
// Реализуйте функцию, которая принимает слово на английском языке в качестве параметра.
// Функция должна возвращать перевод этого слова с помощью словаря, если такой перевод существует. В противном случае, возвращайте nil.
// b. Интерфейс пользователя:
// Создайте функцию, которая предоставляет пользователю две опции:
// Перевести слово.
// Выйти из приложения.
// Если пользователь выбирает опцию перевода слова, предложите ему ввести слово на английском.
// Используйте вашу функцию перевода, чтобы перевести введенное слово и выведите результат. Если слово не найдено в словаре, информируйте пользователя об этом.
// Запуск:
// После того как весь функционал будет реализован, инициируйте запуск приложения.
// Подсказки:
// Убедитесь, что вы обрабатываете различные варианты ввода пользователя, например, если пользователь вводит слово, которого нет в словаре.
// Используйте функцию readLine(), чтобы получить ввод от пользователя.
// Ожидаемый результат: При запуске приложения пользователь видит меню с опциями. После выбора опции "Перевести слово" ему предлагается ввести слово на английском. Приложение затем выдает русский перевод этого слова или сообщает пользователю, что перевод не найден.

var translationDictionary = ["hello": "привет", "world": "мир", "apple": "яблоко"]

func translateWord() {
    print("Введите слово на английском:")
    if let inputWord = readLine()?.lowercased() {
        if let translation = translationDictionary[inputWord] {
            print("Перевод слова '\(inputWord)' на русский: \(translation)")
        } else {
            print("Перевод не найден.")
        }
    }
}

func translatorApp() {
    print("""
        Выберите действие (введите число):
        1 - Перевести слово
        2 - Выйти из приложения
        """)

    if let userAnswer = readLine() {
        switch userAnswer {
        case "1":
            translateWord()
            print("")
            translatorApp()
        case "2":
            print("Работа приложения завершена")
        default:
            print("Ошибка ввода, попробуйте еще раз\n")
            translatorApp()
        }
    }
}

translatorApp()

// MARK: - Task 4. Справочник городов по странам

//4. Задание: Справочник городов по странам
// Описание: Разработайте текстовое приложение для управления базой данных, содержащей страны и их города. Пользователь должен иметь возможность добавлять и удалять города, а также просматривать список городов для определенной страны.
// Требования:
// База данных:
// Создайте словарь, где ключом является название страны, а значением - множество городов этой страны.
// Функциональность:
// a. Добавление города к стране:
// Реализуйте функцию, которая добавляет город к заданной стране.
// Если страна еще не существует в базе данных, создайте новую запись.
// Если страна уже есть в базе данных, просто добавьте город к множеству городов этой страны.
// b. Удаление города из страны:
// Реализуйте функцию, которая удаляет город из заданной страны.
// Если после удаления города у страны не осталось городов, удаляйте страну из базы данных.
// c. Просмотр городов страны:
// Реализуйте функцию, которая отображает список городов для заданной страны.
// Если страны нет в базе данных или у нее нет городов, информируйте пользователя об этом.
// d. Интерфейс пользователя:
// Создайте функцию, предоставляющую пользователю меню с различными действиями.
// Предоставьте опции для добавления города, удаления города, просмотра городов страны и выхода из приложения.
// Запуск:
// После того как весь функционал будет реализован, инициируйте запуск приложения.
// Подсказки:
// Используйте Set<String> для хранения городов каждой страны, чтобы избежать дубликатов.
// Убедитесь, что вы обрабатываете все возможные случаи, например, добавление уже существующего города или удаление несуществующего города.
// Ожидаемый результат: При запуске приложения пользователь видит меню с различными опциями. Он может добавлять города, удалять их или просматривать список городов для определенной страны.
//

var cityDatabase = [String: Set<String>]()

func addCityToCountry() {
    print("Введите название страны:")
    if let country = readLine()?.capitalized {
        print("Введите название города:")
        if let city = readLine()?.capitalized {
            if var cities = cityDatabase[country] {
                cities.insert(city)
                cityDatabase[country] = cities
            } else {
                cityDatabase[country] = [city]
            }
            print("Город '\(city)' успешно добавлен к стране '\(country)'.")
        }
    }
}

func removeCityFromCountry() {
    print("Введите название страны:")
    if let country = readLine()?.capitalized {
        print("Введите название города:")
        if let city = readLine()?.capitalized {
            if var cities = cityDatabase[country] {
                cities.remove(city)
                if cities.isEmpty {
                    cityDatabase.removeValue(forKey: country)
                } else {
                    cityDatabase[country] = cities
                }
                print("Город '\(city)' успешно удален из страны '\(country)'.")
            } else {
                print("Страны '\(country)' или города '\(city)' не существует в базе данных.")
            }
        }
    }
}

func viewCitiesForCountry() {
    print("Введите название страны:")
    if let country = readLine()?.capitalized {
        if let cities = cityDatabase[country] {
            if cities.isEmpty {
                print("У страны '\(country)' нет городов в базе данных.")
            } else {
                print("Города страны '\(country)': \(cities.joined(separator: ", "))")
            }
        } else {
            print("Страны '\(country)' не существует в базе данных.")
        }
    }
}

func countryCityApp() {
    print("""
        Выберите действие (введите число):
        1 - Добавить город к стране
        2 - Удалить город из страны
        3 - Просмотреть города страны
        4 - Выйти из приложения
        """)

    if let userAnswer = readLine() {
        switch userAnswer {
        case "1":
            addCityToCountry()
            print("")
            countryCityApp()
        case "2":
            removeCityFromCountry()
            print("")
            countryCityApp()
        case "3":
            viewCitiesForCountry()
            print("")
            countryCityApp()
        case "4":
            print("Работа приложения завершена")
        default:
            print("Ошибка ввода, попробуйте еще раз\n")
            countryCityApp()
        }
    }
}

countryCityApp()

//MARK: - Task 5. Нахождение общих элементов двух массивов
//5. Задание: Нахождение общих элементов двух массивов
// Описание: Разработайте функцию, которая определяет общие элементы между двумя массивами и возвращает их в виде нового массива.
// Требования:
// Функция commonElements:
// Входные параметры: два массива целых чисел - array1 и array2.
// Возвращаемое значение: массив целых чисел.
// Логика функции:
// Преобразуйте каждый из входных массивов в множества (Set) для устранения возможных дубликатов и для использования встроенных операций множеств.
// Найдите пересечение двух множеств, что даст вам множество общих элементов.
// Преобразуйте результат обратно в массив и верните его.
// Пример использования:
// Создайте два тестовых массива: arrayA и arrayB.
// Вызовите функцию commonElements, передав эти массивы в качестве аргументов.
// Выведите на экран результат выполнения функции.
// Подсказки:
// Порядок элементов в результирующем массиве может зависеть от внутреннего устройства Set, поэтому не обязательно ожидать определенный порядок.

func commonElements(array1: [Int], array2: [Int]) -> [Int] {
    let set1 = Set(array1)
    let set2 = Set(array2)
    let intersection = set1.intersection(set2)
    return Array(intersection)
}

let arrayA = [1, 2, 3, 4, 5]
let arrayB = [3, 4, 5, 6, 7]

let result = commonElements(array1: arrayA, array2: arrayB)
print("Общие элементы: \(result)")

//MARK: - Task 6. Поиск общих друзей двух пользователей

//6 Задание: Поиск общих друзей двух пользователей
// Описание: Разработайте систему для учета дружеских связей и функцию для определения общих друзей между двумя пользователями.
// Требования:
// Словарь friendsList:
// Ключи: строковые значения, представляющие имена пользователей.
// Значения: множества (Set), содержащие имена друзей соответствующего пользователя.
// Функция findCommonFriends:
// Входные параметры: две строки - user1 и user2, представляющие имена пользователей.
// Возвращаемое значение: множество строк (или nil в случае отсутствия какого-либо из пользователей в словаре).
// Логика функции:
// Проверьте, существуют ли оба пользователя в friendsList.
// Если один из пользователей или оба отсутствуют, верните nil.
// Если оба пользователя присутствуют, найдите и верните пересечение их множеств друзей.
// Пример использования:
// Вызовите функцию findCommonFriends, передав в неё имена двух пользователей.
// Определите и выведите результат. Если функция вернула nil, сообщите, что один из пользователей не найден в списке друзей.
// Подсказки:
// Ожидаемый результат:  После вызова функции и передачи в неё имен пользователей, вы должны увидеть их общих друзей. Например, для "Alice" и "Eve" результатом будет: "Общие друзья Alice и Eve: ["David", "Bob"]" (порядок может отличаться). Если один из пользователей отсутствует, вы увидите: "Один из пользователей не найден в списке друзей.".

var friendsList = [
    "Мария": Set(["Екатерина", "Алексей", "Николай"]),
    "Екатерина": Set(["Мария", "Алексей"]),
    "Алексей": Set(["Мария", "Екатерина"]),
    "Николай": Set(["Мария"])
]

func findCommonFriends(user1: String, user2: String) -> Set<String>? {
    guard let friendsUser1 = friendsList[user1], let friendsUser2 = friendsList[user2] else {
        print("Один из пользователей не найден в списке друзей.")
        return nil
    }

    let commonFriends = friendsUser1.intersection(friendsUser2)
    return commonFriends
}

if let commonFriends = findCommonFriends(user1: "Мария", user2: "Николай") {
    print("Общие друзья Марии и Николая: \(commonFriends)")
}

//MARK: - Task 7. Найти уникальные элементы в массиве
//7. Задание: Найти уникальные элементы в массиве
// Описание: Разработайте функцию, которая принимает массив целых чисел и возвращает новый массив, содержащий только уникальные значения из входного массива.
// Требования:
// Функция uniqueElements:
// Входной параметр: массив целых чисел - array.
// Возвращаемое значение: массив целых чисел.
// Логика функции:
// Преобразуйте входной массив в множество (Set). Это автоматически удалит все дубликаты из массива, так как множества содержат только уникальные элементы.
// Преобразуйте полученное множество обратно в массив и верните его.
// Пример использования:
// Вызовите функцию uniqueElements, передав в неё массив чисел.
// Отобразите результат. В результате выполнения функции, все дублирующиеся числа из входного массива должны быть удалены. Например, из массива [1, 2, 3, 1, 2, 4, 5] функция вернет массив [1, 2, 3, 4, 5] (порядок чисел может отличаться).
// Подсказки:
// Ожидаемый результат: После вызова функции и передачи в неё массива, вы должны увидеть массив без дубликатов. Например, для массива [1, 2, 3, 1, 2, 4, 5] результатом может быть: [2, 3, 1, 5, 4] (учтите, что порядок элементов может отличаться).

func uniqueElements(array: [Int]) -> [Int] {
    let uniqueSet = Set(array)
    let uniqueArray = Array(uniqueSet)
    return uniqueArray
}

let inputArray = [1, 2, 3, 1, 2, 4, 5]
let resultArray = uniqueElements(array: inputArray)
print("Уникальные элементы: \(resultArray)")

//MARK: - Task 8. Реализация простого телефонного справочника
//8 Задание:  Реализация простого телефонного справочника
//Описание: Создайте базовую систему управления телефонным справочником, позволяющую добавлять, удалять и искать номера телефонов по именам.
//Требования:
//Справочник:
//Используйте словарь (Dictionary) для хранения пар "имя-номер телефона".
//Функции:
//addNumber:
//Входные параметры: имя (name) и номер телефона (number).
//Добавляет указанный номер телефона для данного имени в справочник.
//removeNumber:
//Входной параметр: имя (name).
//Удаляет номер телефона, связанный с данным именем из справочника.
//findNumber:
//Входной параметр: имя (name).
//Возвращает номер телефона для данного имени (если он есть в справочнике) или nil, если такого имени нет.
//Пример использования:
//Добавьте несколько номеров телефонов в справочник.
//Выполните поиск по имени. Проверьте и отобразите результаты.
//Удалите номер телефона из справочника.
//Попробуйте найти этот номер снова, чтобы удостовериться, что он был удален.
//Ожидаемый результат:
//При добавлении и поиске номеров вы должны получить ожидаемые результаты на основе текущего содержимого справочника. Если имя не найдено в справочнике, функция поиска вернет nil, и вы должны уведомить пользователя об этом.
//Подсказки:
//При работе со словарями в Swift использование метода removeValue(forKey:) удаляет значение для заданного ключа (если оно существует). Если ключа нет, метод не делает ничего.
//Чтобы проверить, существует ли значение для определенного ключа в словаре, вы можете просто использовать индексацию словаря: dictionary[key]. Если ключ отсутствует, вам вернется nil.

var phoneBook = [String: String]()

func addNumber(name: String, number: String) {
    phoneBook[name] = number
}

func removeNumber(name: String) {
    phoneBook.removeValue(forKey: name)
}

func findNumber(name: String) -> String? {
    return phoneBook[name]
}

addNumber(name: "Евгений", number: "123-456")
addNumber(name: "Пётр", number: "789-012")

if let aliceNumber = findNumber(name: "Евгения") {
    print("Номер Евгения: \(aliceNumber)")
} else {
    print("Евгений не найден в справочнике.")
}

removeNumber(name: "Евгений")

if let removedNumber = findNumber(name: "Евгений") {
    print("Номер удаленного контакта: \(removedNumber)")
} else {
    print("Евгений удален из справочника.")
}

//MARK: - Task 9. Реализация теста по умножению

var questionsAndAnswers = [
    "1*1": 1,
    "2*2": 4,
    "3*3": 9,
    "4*4": 16,
    "5*5": 25,
    "6*6": 36,
    "7*7": 49,
    "8*8": 64,
    "9*9": 81,
    "10*10": 100,
]

var correctAnswers = 0

func generateMultiplicationQuestion() -> (String, Int) {
    let randomIndex = Int.random(in: 0..<questionsAndAnswers.count)
    let question = Array(questionsAndAnswers.keys)[randomIndex]
    return (question, questionsAndAnswers[question]!)
}

func determineGrade(_ num: Int) -> String {
    switch num {
    case 0...2: return "2"
    case 3...5: return "3"
    case 6...8: return "4"
    case 9...10: return "5"
    default: return "0"
    }
}

for _ in 1...10 {
    let (question, answer) = generateMultiplicationQuestion()

    print("Сколько будет \(question)?")
    if let userAnswer = readLine(), let userIntAnswer = Int(userAnswer), userIntAnswer == answer {
        correctAnswers += 1
    }
}

let grade = determineGrade(correctAnswers)
print("""
    Правильных ответов: \(correctAnswers)
    Оценка = \(grade)
    """)

//MARK: - TAsk 10. Функция склонения слова "монета" в зависимости от числа

//10 Задание: Функция склонения слова "монета" в зависимости от числа
// Описание:
// Функция coinCase(for:) принимает целое число и возвращает правильное склонение слова "монета" в соответствии с этим числом. Например, для числа 1 функция вернёт "монета", для числа 3 - "монеты", а для числа 5 - "монет".
// Основные моменты:
// Словарь cases:
// Этот словарь содержит основные варианты склонения слова "монета" для последних цифр от 1 до 4.
// 1 - "монета", 2-4 - "монеты".
// lastDigit и lastTwoDigits:
// Эти переменные содержат последнюю цифру числа и последние две цифры числа соответственно.
// Проверка на исключения:
// Для чисел с последними двумя цифрами от 11 до 14 (например, 11, 12, 13, 14) правильное склонение будет "монет", несмотря на то что последняя цифра может быть 1 или 3.
// Определение склонения:
// Если число оканчивается на одну из цифр в словаре cases, функция возвращает соответствующее склонение из словаря.
// В противном случае возвращается "монет".
// Тестирование:
// При запуске этой программы для предоставленного списка чисел будет выведено правильное склонение слова "монета" для каждого числа.
// Примеры:
// "1 монета"
// "2 монеты"
// "5 монет"
// "11 монет"
// "23 монеты"

func coinCase(for number: Int) -> String {
    let cases: [Int: String] = [1: "монета", 2: "монеты", 3: "монеты", 4: "монеты"]
    
    let lastDigit = number % 10
    let lastTwoDigits = number % 100
    
    if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
        return "монет"
    }
    
    if let result = cases[lastDigit] {
        return "\(number) \(result)"
    } else {
        return "\(number) монет"
    }
}

let numbers = [1, 2, 5, 11, 23, 101, 112, 123]
for number in numbers {
    let result = coinCase(for: number)
    print(result)
}

//MARK: - Task 11. Сжатые строки

//11. Сжатые строки
//Создайте функцию которая будет сжимать входящую строку, например
//print(compress("aabcccccaaa")) // Должен вернуть "a2b1c5a3"

func compress(_ input: String) -> String {
    var compressedString = ""
    
    var currentChar: Character?
    var charCount = 0
    
    for char in input {
        if let current = currentChar {
            if char == current {
                charCount += 1
            } else {
                compressedString.append("\(current)\(charCount)")
                currentChar = char
                charCount = 1
            }
        } else {
            currentChar = char
            charCount += 1
        }
    }
    
    if let current = currentChar {
        compressedString.append("\(current)\(charCount)")
    }
    
    return compressedString.count < input.count ? compressedString : input
}

print(compress("aabcccccaaa"))

//MARK: - Task 12. Поиск двух чисел, сумма которых равна заданному числу

//12. Поиск двух чисел, сумма которых равна заданному числу
//Условие: Дан массив целых чисел nums и целое число target. Найдите два числа в массиве, которые в сумме дают target.

func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    var numIndexMap = [Int: Int]()
    
    for (index, num) in nums.enumerated() {
        let complement = target - num
        if let complementIndex = numIndexMap[complement] {
            return [complementIndex, index]
        }
        
        numIndexMap[num] = index
    }
    
    return []
}

let nums = [2, 7, 11, 15]
let target = 9
print(twoSum(nums, target))

//MARK: - Task 13. Первый уникальный символ в строке

//3. Первый уникальный символ в строке
//Условие: Дана строка, найти первый неповторяющийся символ в ней и вернуть его индекс. Если такого нет, вернуть -1.

func firstUniqChar(_ s: String) -> Int {
    var charCount = [Character: Int]()
    
    for char in s {
        charCount[char, default: 0] += 1
    }
    
    for (index, char) in s.enumerated() {
        if charCount[char] == 1 {
            return index
        }
    }
    
    return -1
}

print(firstUniqChar("leetcode"))
